'use strict';

/* global jest, it, expect, describe */
describe('playable', function () {
  var playable = void 0;
  beforeEach(function () {
    playable = Object.assign({}, require('./playable').default);
  });

  it('will export an object', function () {
    expect(playable).toBeInstanceOf(Object);
  });

  describe('componentWillUnmount', function () {
    beforeEach(function () {
      playable.state = {
        player: {}
      };
      playable.detachHandlersFromPlayer = jest.fn();
    });
    it('will attempt to detach any handlers from the player', function () {
      playable.componentWillUnmount();
      expect(playable.detachHandlersFromPlayer).toHaveBeenCalledWith(playable.state.player);
    });
  });

  describe('attachHandlersToPlayer', function () {
    it('will attach handlers from props to the player', function () {
      var player = {};
      var props = { onFinish: function onFinish() {
          return true;
        }, onCancel: function onCancel() {
          return true;
        } };
      playable.attachHandlersToPlayer(player, props);
      expect(player.onfinish).toBe(props.onFinish);
      expect(player.oncancel).toBe(props.onCancel);
    });
  });

  describe('detachHandlersFromPlayer', function () {
    it('will remove handlers from the player', function () {
      var player = { onfinish: function onfinish() {
          return true;
        }, oncancel: function oncancel() {
          return true;
        } };
      playable.detachHandlersFromPlayer(player);
      expect(player.onfinish).toBe(null);
      expect(player.oncancel).toBe(null);
    });
  });

  describe('notifyHandlers', function () {
    describe('without a player', function () {
      beforeEach(function () {
        playable.state = {
          player: null
        };
        playable.props = { onPlay: jest.fn() };
      });

      it('will do nothing', function () {
        playable.notifyHandlers({});
        expect(playable.props.onPlay).not.toHaveBeenCalled();
      });
    });
    describe('with a player', function () {
      beforeEach(function () {
        playable.state = {
          player: {}
        };
        playable.props = {
          onPlay: jest.fn(),
          onPause: jest.fn(),
          onReverse: jest.fn()
        };
      });

      it('will call the appropriate handler in props', function () {
        playable.notifyHandlers('running');
        playable.notifyHandlers('paused');
        playable.notifyHandlers('reversed');
        expect(playable.props.onPlay).toHaveBeenCalledWith(playable.state.player);
        expect(playable.props.onPause).toHaveBeenCalledWith(playable.state.player);
        expect(playable.props.onReverse).toHaveBeenCalledWith(playable.state.player);
      });
    });
  });

  describe('setPlayer', function () {
    describe('without an existing player', function () {
      beforeEach(function () {
        playable.state = {};
        playable.props = { someProps: 'test' };
        playable.setState = jest.fn();
        playable.attachHandlersToPlayer = jest.fn();
      });

      it('will cancel any animation on an existing player', function () {
        var newPlayer = {};
        playable.setPlayer(newPlayer, {});
        expect(playable.setState).toHaveBeenCalledWith({ player: newPlayer });
        expect(playable.attachHandlersToPlayer).toHaveBeenCalledWith(newPlayer, {});
      });

      it('without props, it will use instance props', function () {
        var newPlayer = {};
        playable.setPlayer(newPlayer);
        expect(playable.setState).toHaveBeenCalledWith({ player: newPlayer });
        expect(playable.attachHandlersToPlayer).toHaveBeenCalledWith(newPlayer, playable.props);
      });
    });

    describe('with an existing player', function () {
      var oldPlayer = void 0;
      beforeEach(function () {
        oldPlayer = {
          cancel: jest.fn()
        };
        playable.state = {
          player: oldPlayer
        };
        playable.setState = jest.fn();
        playable.attachHandlersToPlayer = jest.fn();
      });

      it('will cancel any animation on an existing player', function () {
        var newPlayer = {};
        playable.setPlayer(newPlayer, {});
        expect(oldPlayer.cancel).toHaveBeenCalled();
        expect(playable.setState).toHaveBeenCalledWith({ player: newPlayer });
        expect(playable.attachHandlersToPlayer).toHaveBeenCalledWith(newPlayer, {});
      });
    });
  });
});